import numpy as np
import functools, operator
from math import log, exp
from numpy import log1p
import sys

# ------- CONSTANTS ----------#
ALLELE_1 = 1
ALLELE_2 = 2




#----------- Helper Functions --------------#

# Return the sum of two log probabilities
# requires two log probabilities a and b
def sumLogProb(a, b):
	if a > b:
		return a + log1p(exp(b - a))
	else:
		return b + log1p(exp(a - b))





# helper function for computing the probability 
# def pHelper(p, k):
# 	return reduce(operator.add, p[k])



# read in the snp data
# singleLine is a parameter to read in SNP data that's formated by 1 individual / line
def read_file(fileName, singleLine=True):
	individuals = []
	snps = []
	with open(fileName) as f:
		for line in f:

			# split on spaces, separate into list of ID's and snp data
			splitLine = line.split()
			individuals.append(splitLine[0:1])
			snps.append(map(int,splitLine[6:]))

		# convert all snps to integers
		snps = np.array(snps)
		number_individuals = len(individuals)
		print "number of individuals: {0}".format(number_individuals)
		print "number of loci: {0}".format(len(snps[0])/2)

	return individuals, snps

# write the data to a file 
# data is a list of output generated by 
def write_file(data):
	fileName = "structureOutput/output" + str(np.random.randint(1000000,99999999)) + ".txt"
	with open(fileName, 'w') as f:
		for line in data:
			f.write(line + '\n')





def mcmc_no_admixture(individuals, snps, K):
	
	number_individuals = len(individuals)

	num_alleles = 2

	# get the number of loci, should be an even number
	num_loci = len(snps[0]) / 2
	

	# initialize z0 for all individuals from uniform distribution
	z = np.array([np.random.randint(0,K) for _ in range(number_individuals)])
	#z = [2, 1, 2, 1, 2, 2]
	
	'''
	Algorithm overview


	Terminate when likelyhood of data is constant

	'''
	#------ itterate m times  -------- #
	for m in range(20):
		# print "itteration {0}".format(m)

		#--------Step 1----------- #
		# print "Run Step 1"
		# set up nklj, a 3D matrix of counts that is indexed by k-> l-> j
		n = np.zeros((K,num_loci,num_alleles))
		# loop through all individuals
		for idx, individual in enumerate(individuals):

			# all the lists are indexed by a common index
			# this particular individual belongs to population k
			k = z[idx]

			# itterate over each locus 
			# loci within snps for each individuals also allign by index

			# just the loci for the current individual
			# loci stores the diploid SNPS for each locus, so len(loci) should be 2*num_loci
			loci = snps[idx]

			# itterate over each locus
			for locus in range(0,num_loci):

				# grab chromosomes at this locus
				chromosome1, chromosome2 = int(loci[2*locus]), int(loci[2*locus+1])

				#print "allele1: {0}".format(allele1)
				#print "allele2: {0}".format(allele2)
				
				# count alleles 
				for chromosome in [chromosome1, chromosome2]:
					if (chromosome == ALLELE_1):
						n[k][locus][0] += 1
					elif (chromosome == ALLELE_2):
						n[k][locus][1] += 1


		# fill out matrix p , which stores pkl0, where pkl1 = 1 - pkl0
		# use pseudocounts, minimum count is 1
		p = np.zeros((K,num_loci))
		
		for k in range(0,K):
			for l in range(0,num_loci):

				# sample from dirichlet distribution, return the probablility of allele1
				# store as logs
				p[k][l] = log(np.random.dirichlet([1 + n[k][l][0], 1 + n[k][l][1] ])[0])

		# print "population distribution: {0}".format(z)
		# print "matrix: n {0}".format(n)
		# print "p log likelihood (wrong)  {0}".format(p.sum())
		#--------Step 2----------- #
		'''
		Description of Step 2
		We simulate z(i) from Equation A8. We need to calculate the log likelyhood
		 of all the loci for each individual. This will serve as the normalization
		 factor. an individual will be sampled from a population k by a weighted
		 vector [a(k1}/norm, a(k2)/norm, a(k3)/norm] where a is Pr(x(i)|P, z(i)=k) 
		'''
		# print "Run Step 2"
		individuals_changed = 0
		# itterate over each individual
		for idx, individual in enumerate(individuals):

			# just the loci for the current individual
			loci = snps[idx]
			kDistribution = np.array( probHelper(loci, num_loci, p))
			sum_k_dist = reduce(sumLogProb, kDistribution)
			# print "before normalizing: {0}".format(kDistribution)


			# normalize
			kDistribution = map(exp, kDistribution - sum_k_dist)
			#print "after normalizing: {0}".format(kDistribution)



			# sample from this weighted distribution, assign new k to this individual:
			z_new = np.random.choice(K, 1,p=kDistribution)[0]
			if z[idx] != z_new:
				#print "individual {0} changed from {1} to {2}".format(idx, z[idx], z_new)
				individuals_changed += 1
				z[idx] = z_new
		# print "number of individuals reassigned in itteration {0}: {1}".format(m, individuals_changed)
	print "k=0 ind: {0}".format(np.count_nonzero(z == 0))
	print "k=1 ind: {0}".format(np.count_nonzero(z == 1))
	print "k=2 ind: {0}".format(np.count_nonzero(z == 2))
	print "final ancestry assignment: {0}".format(z)





# calculate the product of p's based on equation A8, according to the alleles
# at the particular locus
# using log probabilities
def alleleHelper(pLocus, allele1, allele2):

	# terms = [0,0]
	# for idx, allele in enumerate([allelle1, allele2]):
	# 	if allele == 1:
	# 		terms[idx] = pLocus
	# 	elif allele == 2:
	# 		terms[idx] = log(1 - exp(pLocus))
	# 	else:
	# 		terms[idx] = 0
	# return sum(terms)
	if allele1 == 1:
		term1 = pLocus
	elif allele1 == 2:
		term1 = log(1 - exp(pLocus))
	else:
		term1 = 0

	if allele2 == 1:
		term2 = pLocus
	elif allele2 == 2:
		term2 = log(1 - exp(pLocus))
	else:
		term2 = 0

	return term1 + term2



# compute Pr(x(i)|P, z(i)=k) for all k
def probHelper(loci, num_loci, p):
	# return [ sum([ alleleHelper(pLocus,loci[2*idxLocus],loci[2*idxLocus+1])  for idxLocus, pLocus in enumerate(pk)]) for pk in p]
	kDist = []
	for pk in p:
		
		accum = 0
		for idxLocus, pLocus in enumerate(pk):
			accum += alleleHelper(pLocus, loci[2*idxLocus], loci[2*idxLocus+1])

		kDist.append(accum)

	return kDist


def mcmc_admixture(ids, snps, K=3):
	
	# get the number of loci, should be an even number
	num_loci = len(snps[0]) / 2

	# get number of individuals
	number_individuals = len(ids)

	# each observed allele copy xl(i,a) originated in some unkown population zl(i,a)
	# initialize z0 for all alleles for all individuals from uniform distribution
	z = np.array([ [np.random.randint(0,K) for _ in range(num_loci * 2)] for _ in range(number_individuals)])
	

	# itterate m times
	for m in range(20):

		#--------Step 1----------- #
		# print "Run Step 1"
		# set up nklj, a 3D matrix of counts that is indexed by k-> l-> j
		n = np.zeros((K,num_loci,num_alleles))
		# build nklj matrix
		# itterate over each individual
			for idx, individual in enumerate(individuals):

				# itterate over each locus 
				# loci within snps for each individuals also allign by index

				# just the loci for the current individual
				# loci stores the diploid SNPS for each locus, so len(loci) should be 2*num_loci
				loci = snps[idx]

				# itterate over each locus
				for locus in range(0,num_loci):

					# grab chromosomes at this locus
					chromosome1, chromosome2 = int(loci[2*locus]), int(loci[2*locus+1])

					# grab the populations of origin of the allele copies (of chromosome1 and chromosome2)
					k1, k2 = z[idx][2*locus], z[idx][2*locus+1]

					#print "allele1: {0}".format(allele1)
					#print "allele2: {0}".format(allele2)
					
					# count allele copy 1 
					if (chromosome1 == ALLELE_1):
						n[k1][locus][0] += 1
					elif (chromosome1 == ALLELE_2):
						n[k1][locus][1] += 1

					# count allele copy 2
					if (chromosome2 == ALLELE_1):
						n[k2][locus][0] += 1
					elif (chromosome2 == ALLELE_2):
						n[k2][locus][1] += 1
		#--------END Step 1----------- #

		#--------BEGIN Step 2----------- #










# def logLikelyHood(p):
# 	accum = 0 
# 	for k in 



def main():
	# read in data
	ids, snps = read_file("hapmap3.ped")
	#ids, snps = read_file("thrush", False)
	#ids, snps = read_file("smallTest.ped")

	# run no_admixture many times
	# for run in range(0,30):
	# 	print "run number {0}".format(run)
	# 	mcmc_no_admixture(ids,snps,K=3)


	mcmc_admixture(ids,snps)



if __name__ == "__main__":
	main()